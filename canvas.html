<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  $1  <link rel="stylesheet" href="style.css" />
<title>Spotify Playlist Trimmer (Frontend Only)</title>
  <style>
    :root { --gap: 14px; }
    /* inherit global body styles from site */
    /* header styling inherits from .blob-header in site stylesheet */
    main { padding: 24px; max-width: 900px; margin: 0 auto; }
    h1 { margin: 0 0 8px; font-size: 22px; }
    .muted { color: #555; font-size: 14px; }
    .card { background: #fff; border: 1px solid #eee; box-shadow: 0 1px 2px rgba(0,0,0,0.04); border-radius: 12px; padding: 16px; }
    .row { display: flex; gap: var(--gap); align-items: center; flex-wrap: wrap; }
    .col { display: grid; gap: 8px; }
    input[type="text"], button, select { font: inherit; padding: 10px 12px; border-radius: 10px; border: 1px solid #ddd; background: #fff; }
    input[type="checkbox"] { transform: scale(1.2); }
    button { cursor: pointer; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    #log { white-space: pre-wrap; background: #0a0a0a; color: #d5ffd5; padding: 12px; border-radius: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; max-height: 50vh; overflow: auto; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; background: #f1f1f1; font-size: 12px; }
    footer { color: #666; font-size: 12px; padding: 24px; text-align: center; }
    .progress { height: 10px; background: #eee; border-radius: 999px; overflow: hidden; }
    .progress > div { height: 100%; width: 0%; background: #111; transition: width .2s; }
    .grid { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
    .config-note { font-size: 12px; color: #666; }
    .config-note code { background: #f3f3f3; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <div class="container">
    <header class="blob-header">
      <h1>werd.</h1>
      <nav>
        <a href="index.html">home</a>
        <a href="about.html">about</a>
        <a href="spools.html">spools</a>
      </nav>
    </header>
    <main>
      <h2 style="margin-top:0">canvas</h2>
      <p class="muted">Creates a copy of a playlist without tracks that are already in your Liked Songs.</p>

    <section class="card grid" id="auth-section">
      <div class="row">
        <div class="pill" id="auth-status">Not signed in</div>
        <div id="user-pill" class="pill" style="display:none"></div>
      </div>
      <div class="row">
        <button id="login" class="primary">Sign in with Spotify</button>
        <button id="logout" style="display:none">Sign out</button>
      </div>
      <div class="config-note">This page uses a preconfigured <em>Client ID</em> and will redirect to <code id="redir-label"></code>. Make sure that exact URL is listed in your Spotify app’s <strong>Redirect URIs</strong>.</div>
    </section>

    <section class="card grid">
      <div class="col">
        <label for="playlist-uri">Source playlist URL/URI</label>
        <input id="playlist-uri" type="text" placeholder="e.g. https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M or spotify:playlist:37i9dQZF1DXcBWIGoYBM5M" />
      </div>
      <div class="row">
        <label><input id="refresh-cache" type="checkbox" /> Refresh Liked Songs cache</label>
        <button id="run" class="primary" disabled>Run Trimmer</button>
      </div>
      <div class="progress"><div id="bar"></div></div>
      <div id="stats" class="row"></div>
    </section>

    <section class="card">
      <div id="log"></div>
    </section>
  </main>
  </div>

  <footer>
    Built with vanilla JS + Fetch using Spotify Web API (PKCE). No backend.
  </footer>

  <script>
    // =====================
    // Configuration (edit these)
    // =====================
    // It's OK to embed your CLIENT_ID in frontend code. DO NOT embed your client secret.
    // Use the client ID of your Spotify app. You shared one earlier; replace below if needed.
    const CLIENT_ID = "a511624e55bb4ebaa84621a637f31d9e";

    // Default redirect is the current page URL (canvas.html). Ensure this EXACT value is
    // present in the app's Redirect URIs in the Spotify Developer Dashboard.
    const REDIRECT_URI = new URL(window.location.pathname, window.location.origin).toString();
    // If you host at a subpath or want to be explicit, you can use:
    // const REDIRECT_URI = new URL('canvas.html', window.location.origin).toString();

    // Required scopes
    const SCOPES = [
      'playlist-modify-public',
      'playlist-modify-private',
      'user-library-read'
    ];

    // =====================
    // Utilities & PKCE auth
    // =====================
    const el = id => document.getElementById(id);
    const logEl = el('log');
    const barEl = el('bar');
    const statsEl = el('stats');

    function log(msg) {
      const time = new Date().toLocaleTimeString();
      logEl.textContent += `[${time}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function setProgress(p) { barEl.style.width = `${Math.max(0, Math.min(100, p))}%`; }

    function parsePlaylistId(input) {
      if (!input) return null;
      try {
        if (input.startsWith('spotify:')) {
          const parts = input.split(':');
          return parts[2];
        }
        const url = new URL(input);
        const paths = url.pathname.split('/').filter(Boolean);
        if (paths[0] === 'playlist') return paths[1];
      } catch {}
      return input; // assume raw ID
    }

    // Token storage (per-user). Keys are namespaced by the Spotify user id when known.
    const Storage = {
      set(k, v) { localStorage.setItem(k, JSON.stringify(v)); },
      get(k, d=null) { try { return JSON.parse(localStorage.getItem(k)) ?? d; } catch { return d; } },
      del(k) { localStorage.removeItem(k); }
    };

    // PKCE helpers
    async function sha256(plain) { const enc = new TextEncoder().encode(plain); const buf = await crypto.subtle.digest('SHA-256', enc); return new Uint8Array(buf); }
    function base64url(bytes) { return btoa(String.fromCharCode(...bytes)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }
    function randStr(len=64) { const a = new Uint8Array(len); crypto.getRandomValues(a); return Array.from(a, b => ('0' + b.toString(16)).slice(-2)).join(''); }

    const Auth = {
      key: 'sp_pkce_state',
      async login() {
        const state = randStr(16);
        const verifier = randStr(64);
        const challenge = base64url(await sha256(verifier));
        Storage.set(this.key, { state, verifier, clientId: CLIENT_ID, redirectUri: REDIRECT_URI });
        const url = new URL('https://accounts.spotify.com/authorize');
        url.searchParams.set('response_type', 'code');
        url.searchParams.set('client_id', CLIENT_ID);
        url.searchParams.set('redirect_uri', REDIRECT_URI);
        url.searchParams.set('scope', SCOPES.join(' '));
        url.searchParams.set('code_challenge_method', 'S256');
        url.searchParams.set('code_challenge', challenge);
        url.searchParams.set('state', state);
        window.location.assign(url.toString());
      },
      async complete() {
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        const state = params.get('state');
        const stored = Storage.get(this.key);
        if (!code || !stored || state !== stored.state) return null;
        // Clean URL
        window.history.replaceState({}, document.title, window.location.pathname);
        // Exchange code for tokens (PKCE — no secret)
        const body = new URLSearchParams({
          grant_type: 'authorization_code',
          code,
          redirect_uri: stored.redirectUri,
          client_id: stored.clientId,
          code_verifier: stored.verifier,
        });
        const res = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body
        });
        if (!res.ok) throw new Error('Token exchange failed');
        const tok = await res.json();
        Storage.set('sp_tokens', { ...tok, ts: Date.now(), clientId: stored.clientId, redirectUri: stored.redirectUri });
        Storage.del(this.key);
        return tok;
      },
      async refreshIfNeeded() {
        const tok = Storage.get('sp_tokens');
        if (!tok) return null;
        const age = (Date.now() - (tok.ts || 0)) / 1000;
        if (age < (tok.expires_in || 3600) - 60) return tok; // not expired
        if (!tok.refresh_token) return tok; // nothing we can do; re-login needed
        const body = new URLSearchParams({
          grant_type: 'refresh_token',
          refresh_token: tok.refresh_token,
          client_id: tok.clientId,
        });
        const res = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body
        });
        if (!res.ok) return tok; // fallback, let API call 401 and we re-auth
        const nt = await res.json();
        const merged = { ...tok, ...nt, ts: Date.now() };
        Storage.set('sp_tokens', merged);
        return merged;
      },
      logout() { Storage.del('sp_tokens'); }
    };

    // API wrapper
    const API = {
      async fetch(path, init={}) {
        let tok = await Auth.refreshIfNeeded();
        if (!tok) throw new Error('Not authenticated');
        const res = await fetch(`https://api.spotify.com/v1${path}`, {
          ...init,
          headers: { 'Authorization': `Bearer ${tok.access_token}`, 'Content-Type': 'application/json', ...(init.headers||{}) }
        });
        if (res.status === 401) { // try once more
          Storage.del('sp_tokens');
          throw new Error('Session expired. Please sign in again.');
        }
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`API ${res.status}: ${text}`);
        }
        return res.json();
      },
      me() { return this.fetch('/me'); },
      async getAllSavedTrackIds(onProgress) {
        let items = []; let next = '/me/tracks?limit=50';
        while (next) {
          const data = await this.fetch(next.replace('https://api.spotify.com/v1',''));
          items.push(...data.items);
          onProgress?.(items.length);
          next = data.next;
        }
        return items.filter(t => t.track && t.track.id).map(t => t.track.id);
      },
      async getAllPlaylistTrackIds(playlistId, onProgress) {
        let items = []; let next = `/playlists/${playlistId}/tracks?limit=100`;
        while (next) {
          const data = await this.fetch(next.replace('https://api.spotify.com/v1',''));
          items.push(...data.items);
          onProgress?.(items.length);
          next = data.next;
        }
        return items.filter(t => t.track && t.track.id).map(t => t.track.id);
      },
      createPlaylist(userId, name, description, isPublic=false) {
        return this.fetch(`/users/${encodeURIComponent(userId)}/playlists`, {
          method: 'POST', body: JSON.stringify({ name, description, public: isPublic })
        });
      },
      addTracks(playlistId, trackIds) {
        const uris = trackIds.map(id => `spotify:track:${id}`);
        return this.fetch(`/playlists/${playlistId}/tracks`, { method: 'POST', body: JSON.stringify({ uris }) });
      },
      updateDetails(playlistId, details) { return this.fetch(`/playlists/${playlistId}`, { method: 'PUT', body: JSON.stringify(details) }); }
    };

    // Liked songs cache (per-user) in localStorage
    const Cache = {
      key(uid) { return `sp_liked_cache_${uid}`; },
      get(uid) { return Storage.get(this.key(uid)); },
      set(uid, data) { Storage.set(this.key(uid), data); }
    };

    // =====================
    // UI Logic
    // =====================
    let currentUser = null;

    async function ensureAuthedUI() {
      const toks = Storage.get('sp_tokens');
      const authed = !!toks?.access_token;
      el('auth-status').textContent = authed ? 'Signed in' : 'Not signed in';
      el('login').style.display = authed ? 'none' : '';
      el('logout').style.display = authed ? '' : 'none';
      el('run').disabled = !authed;
      el('redir-label').textContent = REDIRECT_URI;
      if (authed) {
        try {
          currentUser = await API.me();
          el('user-pill').style.display = '';
          el('user-pill').textContent = `${currentUser.display_name || currentUser.id}`;
          statsEl.textContent = '';
        } catch (e) {
          log(`Auth check error: ${e.message}`);
        }
      } else {
        currentUser = null;
        el('user-pill').style.display = 'none';
      }
    }

    el('login').addEventListener('click', async () => {
      await Auth.login();
    });

    el('logout').addEventListener('click', () => { Auth.logout(); ensureAuthedUI(); log('Signed out.'); });

    async function maybeCompleteAuth() {
      try {
        const t = await Auth.complete();
        if (t) log('Authenticated with Spotify.');
      } catch (e) { log(`Auth completion failed: ${e.message}`); }
      await ensureAuthedUI();
    }

    async function runTrimmer() {
      if (!currentUser) { alert('Please sign in first.'); return; }
      const playlistInput = el('playlist-uri').value.trim();
      const playlistId = parsePlaylistId(playlistInput);
      if (!playlistId) { alert('Enter a playlist URL/URI/ID.'); return; }

      setProgress(0); log('Starting…');

      // 1) Liked songs cache
      const useRefresh = el('refresh-cache').checked;
      let cache = Cache.get(currentUser.id);
      let likedIds = [];
      if (cache && !useRefresh) {
        likedIds = cache.ids || [];
        log(`Loaded ${likedIds.length} liked tracks from local cache.`);
      } else {
        log('Fetching Liked Songs…');
        likedIds = await API.getAllSavedTrackIds(count => {
          setProgress(Math.min(40, Math.floor(count/5))); // arbitrary progress mapping
        });
        Cache.set(currentUser.id, { ids: likedIds, updatedAt: Date.now() });
        log(`Cached ${likedIds.length} liked tracks.`);
      }

      // 2) Source playlist tracks
      log('Fetching source playlist tracks…');
      const plIds = await API.getAllPlaylistTrackIds(playlistId, count => {
        setProgress(40 + Math.min(30, Math.floor(count/3)));
      });
      log(`Playlist contains ${plIds.length} tracks.`);

      // 3) Filter
      const likedSet = new Set(likedIds);
      const filtered = plIds.filter(id => !likedSet.has(id));
      const removedCount = plIds.length - filtered.length;
      statsEl.innerHTML = `<div class="pill">Playlist: ${plIds.length}</div><div class="pill">Liked: ${likedIds.length}</div><div class="pill">Removed (already liked): ${removedCount}</div><div class="pill">Remaining: ${filtered.length}</div>`;
      log(`Tracks to keep (not in Liked Songs): ${filtered.length}`);

      if (filtered.length === 0) { log('Nothing to do — every track is already in Liked Songs.'); setProgress(100); return; }

      // 4) Create new playlist
      const timestamp = new Date();
      const pad = n => String(n).padStart(2,'0');
      const playlistName = `EXT:trim:${timestamp.getFullYear()}-${pad(timestamp.getMonth()+1)}-${pad(timestamp.getDate())}-${pad(timestamp.getHours())}${pad(timestamp.getMinutes())}`;
      log(`Creating new playlist: ${playlistName}`);
      const created = await API.createPlaylist(currentUser.id, playlistName, '', false);
      log(`Created: ${created.external_urls?.spotify || created.id}`);

      // 5) Add tracks in batches of 100
      log('Adding tracks…');
      const batchSize = 100;
      for (let i=0; i<filtered.length; i+=batchSize) {
        const batch = filtered.slice(i, i+batchSize);
        await API.addTracks(created.id, batch);
        const done = Math.min(filtered.length, i+batch.length);
        setProgress(75 + Math.floor(24 * (done/filtered.length)));
        log(`Added ${done}/${filtered.length}`);
      }

      // 6) Update description
      const srcUri = playlistInput.startsWith('spotify:') ? playlistInput : `spotify:playlist:${playlistId}`;
      const desc = `src::${srcUri} | archive_update::${(el('refresh-cache').checked).toString().toUpperCase()} | cnt_removed::${removedCount}`;
      await API.updateDetails(created.id, { description: desc });
      log(`Description set.`);

      setProgress(100);
      log('Done.');
    }

    el('run').addEventListener('click', () => {
      runTrimmer().catch(e => log(`Error: ${e.message}`));
    });

    // Boot
    maybeCompleteAuth();
    ensureAuthedUI();
  </script>
</body>
</html>
