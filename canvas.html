<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spotify Playlist Trimmer (Frontend Only)</title>
  <style>
    :root { --gap: 14px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; color: #111; background: #fafafa; }
    header { padding: 24px; border-bottom: 1px solid #eee; background: #fff; position: sticky; top: 0; z-index: 2; }
    main { padding: 24px; max-width: 900px; margin: 0 auto; }
    h1 { margin: 0 0 8px; font-size: 22px; }
    .muted { color: #555; font-size: 14px; }
    .card { background: #fff; border: 1px solid #eee; box-shadow: 0 1px 2px rgba(0,0,0,0.04); border-radius: 12px; padding: 16px; }
    .row { display: flex; gap: var(--gap); align-items: center; flex-wrap: wrap; }
    .col { display: grid; gap: 8px; }
    input[type="text"], button, select { font: inherit; padding: 10px 12px; border-radius: 10px; border: 1px solid #ddd; background: #fff; }
    input[type="checkbox"] { transform: scale(1.2); }
    button { cursor: pointer; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    #log { white-space: pre-wrap; background: #0a0a0a; color: #d5ffd5; padding: 12px; border-radius: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; max-height: 50vh; overflow: auto; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; background: #f1f1f1; font-size: 12px; }
    footer { color: #666; font-size: 12px; padding: 24px; text-align: center; }
    .progress { height: 10px; background: #eee; border-radius: 999px; overflow: hidden; }
    .progress > div { height: 100%; width: 0%; background: #111; transition: width .2s; }
    .grid { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
  </style>
</head>
<body>
  <header>
    <h1>Spotify Playlist Trimmer</h1>
    <div class="muted">Creates a copy of a playlist without tracks that are already in your Liked Songs.</div>
  </header>
  <main>
    <section class="card grid" id="auth-section">
      <div class="row">
        <div class="pill" id="auth-status">Not signed in</div>
        <div id="user-pill" class="pill" style="display:none"></div>
      </div>
      <div class="row">
        <input id="client-id" type="text" placeholder="Spotify Client ID" style="flex:1 1 280px" />
        <input id="redirect-uri" type="text" placeholder="Redirect URI (e.g., https://yourdomain.com/)" style="flex:1 1 320px" />
        <button id="login" class="primary">Sign in with Spotify</button>
        <button id="logout" style="display:none">Sign out</button>
      </div>
      <div class="muted">Your Client ID is safe to expose on the web. Do <strong>not</strong> use a Client Secret here. This page uses the Authorization Code <strong>PKCE</strong> flow entirely in-browser.</div>
    </section>

    <section class="card grid">
      <div class="col">
        <label for="playlist-uri">Source playlist URL/URI</label>
        <input id="playlist-uri" type="text" placeholder="e.g. https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M or spotify:playlist:37i9dQZF1DXcBWIGoYBM5M" />
      </div>
      <div class="row">
        <label><input id="refresh-cache" type="checkbox" /> Refresh Liked Songs cache</label>
        <button id="run" class="primary" disabled>Run Trimmer</button>
      </div>
      <div class="progress"><div id="bar"></div></div>
      <div id="stats" class="row"></div>
    </section>

    <section class="card">
      <div id="log"></div>
    </section>
  </main>

  <footer>
    Built with vanilla JS + Fetch using Spotify Web API (PKCE). No backend.
  </footer>

  <script>
    // =====================
    // Utilities & PKCE auth
    // =====================
    const SCOPES = [
      'playlist-modify-public',
      'playlist-modify-private',
      'user-library-read'
    ];

    const el = id => document.getElementById(id);
    const logEl = el('log');
    const barEl = el('bar');
    const statsEl = el('stats');

    function log(msg) {
      const time = new Date().toLocaleTimeString();
      logEl.textContent += `[${time}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function pct(n, d) { return d ? Math.round(n / d * 100) : 0; }
    function setProgress(p) { barEl.style.width = `${Math.max(0, Math.min(100, p))}%`; }

    function parsePlaylistId(input) {
      if (!input) return null;
      try {
        if (input.startsWith('spotify:')) {
          const parts = input.split(':');
          return parts[2];
        }
        const url = new URL(input);
        const paths = url.pathname.split('/').filter(Boolean);
        if (paths[0] === 'playlist') return paths[1];
      } catch {}
      return input; // assume raw ID
    }

    // Token storage (per-user). Keys are namespaced by the Spotify user id when known.
    const Storage = {
      set(k, v) { localStorage.setItem(k, JSON.stringify(v)); },
      get(k, d=null) { try { return JSON.parse(localStorage.getItem(k)) ?? d; } catch { return d; } },
      del(k) { localStorage.removeItem(k); }
    };

    // PKCE helpers
    async function sha256(plain) { const enc = new TextEncoder().encode(plain); const buf = await crypto.subtle.digest('SHA-256', enc); return new Uint8Array(buf); }
    function base64url(bytes) { return btoa(String.fromCharCode(...bytes)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }
    function randStr(len=64) { const a = new Uint8Array(len); crypto.getRandomValues(a); return Array.from(a, b => ('0' + b.toString(16)).slice(-2)).join(''); }

    const Auth = {
      key: 'sp_pkce_state',
      async login(clientId, redirectUri) {
        const state = randStr(16);
        const verifier = randStr(64);
        const challenge = base64url(await sha256(verifier));
        Storage.set(this.key, { state, verifier, clientId, redirectUri });
        const url = new URL('https://accounts.spotify.com/authorize');
        url.searchParams.set('response_type', 'code');
        url.searchParams.set('client_id', clientId);
        url.searchParams.set('redirect_uri', redirectUri);
        url.searchParams.set('scope', SCOPES.join(' '));
        url.searchParams.set('code_challenge_method', 'S256');
        url.searchParams.set('code_challenge', challenge);
        url.searchParams.set('state', state);
        window.location.assign(url.toString());
      },
      async complete() {
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        const state = params.get('state');
        const stored = Storage.get(this.key);
        if (!code || !stored || state !== stored.state) return null;
        // Clean URL
        window.history.replaceState({}, document.title, window.location.pathname);
        // Exchange code for tokens (PKCE — no secret)
        const body = new URLSearchParams({
          grant_type: 'authorization_code',
          code,
          redirect_uri: stored.redirectUri,
          client_id: stored.clientId,
          code_verifier: stored.verifier,
        });
        const res = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body
        });
        if (!res.ok) throw new Error('Token exchange failed');
        const tok = await res.json();
        Storage.set('sp_tokens', { ...tok, ts: Date.now(), clientId: stored.clientId, redirectUri: stored.redirectUri });
        Storage.del(this.key);
        return tok;
      },
      async refreshIfNeeded() {
        const tok = Storage.get('sp_tokens');
        if (!tok) return null;
        const age = (Date.now() - (tok.ts || 0)) / 1000;
        if (age < (tok.expires_in || 3600) - 60) return tok; // not expired
        if (!tok.refresh_token) return tok; // nothing we can do; re-login needed
        const body = new URLSearchParams({
          grant_type: 'refresh_token',
          refresh_token: tok.refresh_token,
          client_id: tok.clientId,
        });
        const res = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body
        });
        if (!res.ok) return tok; // fallback, let API call 401 and we re-auth
        const nt = await res.json();
        const merged = { ...tok, ...nt, ts: Date.now() };
        Storage.set('sp_tokens', merged);
        return merged;
      },
      logout() { Storage.del('sp_tokens'); }
    };

    // API wrapper
    const API = {
      async fetch(path, init={}) {
        let tok = await Auth.refreshIfNeeded();
        if (!tok) throw new Error('Not authenticated');
        const res = await fetch(`https://api.spotify.com/v1${path}`, {
          ...init,
          headers: { 'Authorization': `Bearer ${tok.access_token}`, 'Content-Type': 'application/json', ...(init.headers||{}) }
        });
        if (res.status === 401) { // try once more
          Storage.del('sp_tokens');
          throw new Error('Session expired. Please sign in again.');
        }
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`API ${res.status}: ${text}`);
        }
        return res.json();
      },
      me() { return this.fetch('/me'); },
      async getAllSavedTrackIds(onProgress) {
        let items = []; let next = '/me/tracks?limit=50'; let page = 0;
        while (next) {
          const data = await this.fetch(next.replace('https://api.spotify.com/v1',''));
          items.push(...data.items);
          page++;
          onProgress?.(items.length);
          next = data.next;
        }
        return items.filter(t => t.track && t.track.id).map(t => t.track.id);
      },
      async getAllPlaylistTrackIds(playlistId, onProgress) {
        let items = []; let next = `/playlists/${playlistId}/tracks?limit=100`; let page = 0;
        while (next) {
          const data = await this.fetch(next.replace('https://api.spotify.com/v1',''));
          items.push(...data.items);
          page++;
          onProgress?.(items.length);
          next = data.next;
        }
        return items.filter(t => t.track && t.track.id).map(t => t.track.id);
      },
      createPlaylist(userId, name, description, isPublic=false) {
        return this.fetch(`/users/${encodeURIComponent(userId)}/playlists`, {
          method: 'POST', body: JSON.stringify({ name, description, public: isPublic })
        });
      },
      addTracks(playlistId, trackIds) {
        const uris = trackIds.map(id => `spotify:track:${id}`);
        return this.fetch(`/playlists/${playlistId}/tracks`, { method: 'POST', body: JSON.stringify({ uris }) });
      },
      updateDetails(playlistId, details) { return this.fetch(`/playlists/${playlistId}`, { method: 'PUT', body: JSON.stringify(details) }); }
    };

    // Liked songs cache (per-user) in localStorage
    const Cache = {
      key(uid) { return `sp_liked_cache_${uid}`; },
      get(uid) { return Storage.get(this.key(uid)); },
      set(uid, data) { Storage.set(this.key(uid), data); }
    };

    // =====================
    // UI Logic
    // =====================
    let currentUser = null;

    async function ensureAuthedUI() {
      const toks = Storage.get('sp_tokens');
      const authed = !!toks?.access_token;
      el('auth-status').textContent = authed ? 'Signed in' : 'Not signed in';
      el('login').style.display = authed ? 'none' : '';
      el('logout').style.display = authed ? '' : 'none';
      el('run').disabled = !authed;
      if (authed) {
        try {
          currentUser = await API.me();
          el('user-pill').style.display = '';
          el('user-pill').textContent = `${currentUser.display_name || currentUser.id}`;
          statsEl.textContent = '';
        } catch (e) {
          log(`Auth check error: ${e.message}`);
        }
      } else {
        currentUser = null;
        el('user-pill').style.display = 'none';
      }
    }

    el('login').addEventListener('click', async () => {
      const clientId = el('client-id').value.trim();
      const redirectUri = el('redirect-uri').value.trim();
      if (!clientId || !redirectUri) { alert('Enter Client ID and Redirect URI first.'); return; }
      await Auth.login(clientId, redirectUri);
    });

    el('logout').addEventListener('click', () => { Auth.logout(); ensureAuthedUI(); log('Signed out.'); });

    async function maybeCompleteAuth() {
      try {
        const t = await Auth.complete();
        if (t) log('Authenticated with Spotify.');
      } catch (e) { log(`Auth completion failed: ${e.message}`); }
      await ensureAuthedUI();
    }

    async function runTrimmer() {
      if (!currentUser) { alert('Please sign in first.'); return; }
      const playlistInput = el('playlist-uri').value.trim();
      const playlistId = parsePlaylistId(playlistInput);
      if (!playlistId) { alert('Enter a playlist URL/URI/ID.'); return; }

      setProgress(0); log('Starting…');

      // 1) Liked songs cache
      const useRefresh = el('refresh-cache').checked;
      let cache = Cache.get(currentUser.id);
      let likedIds = [];
      if (cache && !useRefresh) {
        likedIds = cache.ids || [];
        log(`Loaded ${likedIds.length} liked tracks from local cache.`);
      } else {
        log('Fetching Liked Songs…');
        likedIds = await API.getAllSavedTrackIds(count => {
          setProgress(Math.min(40, Math.floor(count/5))); // arbitrary progress mapping
        });
        Cache.set(currentUser.id, { ids: likedIds, updatedAt: Date.now() });
        log(`Cached ${likedIds.length} liked tracks.`);
      }

      // 2) Source playlist tracks
      log('Fetching source playlist tracks…');
      const plIds = await API.getAllPlaylistTrackIds(playlistId, count => {
        setProgress(40 + Math.min(30, Math.floor(count/3)));
      });
      log(`Playlist contains ${plIds.length} tracks.`);

      // 3) Filter
      const likedSet = new Set(likedIds);
      const filtered = plIds.filter(id => !likedSet.has(id));
      const removedCount = plIds.length - filtered.length;
      statsEl.innerHTML = `<div class="pill">Playlist: ${plIds.length}</div><div class="pill">Liked: ${likedIds.length}</div><div class="pill">Removed (already liked): ${removedCount}</div><div class="pill">Remaining: ${filtered.length}</div>`;
      log(`Tracks to keep (not in Liked Songs): ${filtered.length}`);

      if (filtered.length === 0) { log('Nothing to do — every track is already in Liked Songs.'); setProgress(100); return; }

      // 4) Create new playlist
      const timestamp = new Date();
      const pad = n => String(n).padStart(2,'0');
      const playlistName = `EXT:trim:${timestamp.getFullYear()}-${pad(timestamp.getMonth()+1)}-${pad(timestamp.getDate())}-${pad(timestamp.getHours())}${pad(timestamp.getMinutes())}`;
      log(`Creating new playlist: ${playlistName}`);
      const created = await API.createPlaylist(currentUser.id, playlistName, '', false);
      log(`Created: ${created.external_urls?.spotify || created.id}`);

      // 5) Add tracks in batches of 100
      log('Adding tracks…');
      const batchSize = 100;
      for (let i=0; i<filtered.length; i+=batchSize) {
        const batch = filtered.slice(i, i+batchSize);
        await API.addTracks(created.id, batch);
        const done = Math.min(filtered.length, i+batch.length);
        setProgress(75 + Math.floor(24 * (done/filtered.length)));
        log(`Added ${done}/${filtered.length}`);
      }

      // 6) Update description
      const srcUri = playlistInput.startsWith('spotify:') ? playlistInput : `spotify:playlist:${playlistId}`;
      const desc = `src::${srcUri} | archive_update::${(el('refresh-cache').checked).toString().toUpperCase()} | cnt_removed::${removedCount}`;
      await API.updateDetails(created.id, { description: desc });
      log(`Description set.`);

      setProgress(100);
      log('Done.');
    }

    el('run').addEventListener('click', () => {
      runTrimmer().catch(e => log(`Error: ${e.message}`));
    });

    // Boot
    maybeCompleteAuth();
    ensureAuthedUI();
  </script>
</body>
</html>
